PART 1 	데이터 모델링의 이해

CHAPTER 1. 데이터 모델링의 이해

01 데이터 모델의 이해

	1.	데이터베이스의 모델링 : 현실 세계를 단순화하여 표현하는 기법

	2.	모델링의 특징
	1.	추상화(Abstraction)
	2.	단순화(Simplification)
	3.	명확화(Clarity)
	4.	시스템 구현 및 업무형상화

	3.	모델링의 세 가지 관점
	1.	데이터 관점(What, Data)
	2.	프로세스 관점(How, Process)
	3.	데이터와 프로세스의 상관 관점(Data vs. Process, Interaction)

	4.	모델링의 세 가지 단계
	1.	개념적 데이터 모델링(Conceptual Data Modeling) 
	•	전사적(기업전체) 데이터 모델링 수행 시 행해지며 추상화 레벨이 가장 높은 모델링
	•	 업무 중심적
	2.	논리적 데이터 모델링(Logical Data Modeling) 
	•	재사용성 높음
	3.	물리적 데이터 모델링(Physical Data Modeling)
	•	실제 데이터베이스로 구현 가능
	•	물리적인 성격을 고려함.

	5.	데이터의 독립성
	1.	ANSI-SPARC에서 정의한 3단계 스키마구조(tree-level architecture)
	1.	외부 스키마(External Schema)
	•	사용자의 관점 단계
	2.	개념 스키마(Conceptual Schema)
	•	통합된 관점 단계
	•	전체 데이터 베이스를 나타내는 것
	3.	내부 스키마(Interval Schema)
	•	물리적인 관점 단계.
	•	실질적인 데이터의 저장 구조나 컬럼 정의,  인덱스 등이 포함된다.
	2.	3단계 스키마 구조가 보장하는 독립성
	1.	논리적 독립성 : 개념 스키마가 변경되어도 외부 스키마는 영향받지 않음
	2.	물리적 독립성 : 내부 스키마가 변경되어도 외부/개념 스키마는 영향받지 않음

	6.	ERD(Entity Relationship Diagram)
	1. ERD 표기 방식
￼


	2.	IE/Crow's Foot 표기법
￼

	3.	ERD 작성 순서
	1.	엔터티를 도출하고 그린다.
	2.	엔터티를 적절하게 배치한다.
	3.	엔터티 간의 관계를 설정한다.
	4.	관계명을 기입한다.
	5.	관계의 참여도를 기입한다.
	6.	관계의 필수/선택 여부를 기입한다.


02 엔터티(Entity)
	1.	엔터티란
	•	엔터티의 사전적인 의미는 '독립체'이다.
	•	데이터 베이스에서 식별이 가능한 객체라는 의미를 가지고 있다.
	•	업무에서 쓰이는 데이터를 용도별로 분류한 그룹이라고 할 수 있다.
￼

	2.	엔터티의 특징
	1.	업무에서 쓰이는 정보여야 함
	2.	유니크함을 보장할 수 있는 식별자가 있어야 함
	3.	2개 이상의 인스턴스를 가지고 있어야 함
	4.	2개 이상의 속성을 가지고 있어야 함
	5.	다른 엔터티와 1개 이상의 관계를 가지고 있어야 함

	3.	엔터티의 분류
	1.	유형 vs 무형		
￼
	2.	발생시점 
￼

03 속성(Attribute)
	1.	속성
	•	엔터티의 특징을 나타내는 최소의 데이터 단위

	2.	속성값
	•	엔터티에 속한 하나의 인스턴스를 구체적으로 나타내주는 데이터.
	•	하나의 속성은 한 개의 속성값만 가질 수 있다.

	3.	엔터티, 인스턴스, 속성, 속성값의 관계
	1.	한 개의 엔터티는 두 개 이상의 인스턴스를 갖는다.
	2.	한 개의 인스턴스는 두 개 이상의 속성을 갖는다.
	3.	한 개의 속성은 하나의 속성값을 갖는다.

	4.	분류
	1.	특성에 따른 분류
￼
	2. 구성방식에 따른 분류
￼

	5.	도메인(Domain)
	•	속성이 가질 수 있는 속성값의 범위 
	6.	속성의 명칭 부여
	•	약어 가급적 제한(괘씸함.)
	•	유일성 확보
	•	서술식 사용 금지

04 관계(Relationship)
	1.	관계
	•	엔터티와 엔터티와의 관계
	2.	존재 관계
	•	존재 자체로 연관성이 있는 관계
	3.	행위 관계
	•	특정한 행위를 함으로써 연관성이 생기는 관계를 의미.
	4.	 표기법
￼
	1.	관계명
	•	관계명은 반드시 명확한 문장으로 표현해야 하며 현재형이어야 한다.
￼
	2.	관계차수
￼
	3. 관계선택사양(선택성)
￼

두 개의 엔터티 사이에서 관계를 도출할 때 체크 할 사항
	1.	두 개의 엔터티 사이에 관심있는 연관규칙이 존재하는가?
	2.	두 개의 엔터티 사이에 정보의 조합이 발생되는가?
	3.	업무기술서, 장표에 관계연결에 대한 규칙이 서술되어 있는가?
	4.	업무기술서, 장표에 관계연결을 가능하게 하는 동사(Verb)가 있는가?


04 식별자(Identifiers)
	1.	식별자 : 인스턴스를 구분 가능하게 만들어주는 대표 격인 속성
	2.	주식별자
￼
	3.	분류
	1.	대표성 여부
￼
	2. 스스로 생성되었는지 여부
￼
	3. 단일 속성의 여부
￼
	4. 대체 여부
￼

	4.	식별자 관계 vs. 비식별자 관계
	1.	식별자 관계(Identification Relationship)
	•	부모 엔터티의 식별자가 자식 엔터티의 주식별자가 되는 관계이다.
	•	주식별자는 반드시 존재해야 한다.(부모 엔터티가 있어야 생성 가능하다.)
	2.	비식별자 관계(Non Identification Relationship)
	•	부모 엔터티의 식별자가 자식 엔터티의 주식별자가 아닌 일반 속성이 되는 관계이다.
	•	일반 속성의 속성값은 NULL이 될 수도 있으므로 부모 엔터티가 없는 자식 엔터티 생성이 가능하다.

엔터티(Entity) = 테이블
속성(Attribute) = 컬럼
인스턴스(Instance) = 행


성능 데이터 모델링
	1.	성능 향상을 목적으로 설계단계의 데이터 모델링에 반영될 수 있도록 하는 것.
	2.	데이터 증가가 빠를수록 성능저하에 따른 성능개선비용은 증가한다.
	3.	데이터모델은 성능을 튜닝하면서 변경이 될 수 있는 특징이 있다.
	4.	분석/설계 단계에서 성능을 고려한 데이터모델링을 수행할 경우 성능 저하에 따른 Rework비용을 최소화 할 수 있는 기회를 가지게 된다.

성능을 고려한 데이터 모델링의 순서
	1.	정규화
	2.	용량산정
	3.	트랜잭션(쪼갤 수 없는 업무 처리의 최소 단위)
	4.	반정규화 
	5.	PK/FK 조정
	6.	성능관점 검증

분산 데이터베이스 = 카카오.

/////////////////////////////////////////////////////////////////


데이터 모델링을 할 때 지양해야 할 점(유의점)
	•	중복(Duplication)
	•	비유연성(Inflexibility)
	•	비일관성(Inconsistency)







CHAPTER2 데이터 모델과 SQL

01. 정규화(Normalization)

	1.	제1정규형 : 모든 속성은 반드시 하나의 값만 가져야 한다.
	2.	제2정규형 : 엔티티의 모든 일반속성은 반드시 모든 주식별자에 종속되어야 한다.
	3.	제3정규형 : 주식별자가 아닌 모든 속성 간에는 서로 종속될 수 없다. (이행 함수 종속성 제거)
	4.	주의사항 : 지나친 정규화는 오히려 성능 저하를 일으킬 수 있다.


02. 반정규화(De-Normalization)

	1.	테이블 반정규화
￼
	1.	테이블 병합
	•	업무 프로세스 상 JOIN이 필요한 경우가 많아 테이블을 통합하는 것이 성능 측면에서 유리할 경우 고려한다. 1 : M 관계 테이블 병합의 경우 1쪽에 해당하는 엔터티의 속성 개수가 많으면 병합했을 경우 중복 데이터가 많아지므로 테이블 병합에 적절하지 못하다.

	⁃	슈퍼/서브 타입 데이터 모델의 변환기술
	1.	개별로 발생되는 트랜잭션에 대해서는 개별 테이블로 구성
	2.	슈퍼타입+서브타입에 대해 발생되는 트랜잭션에 대해서는 슈퍼타입+서브타입 테이블로 구성
	3.	전체를 하나로 묶어 트랜잭션이 발생할 때는 하나의 테이블로 구성 

	2.	컬럼 반정규화
	1. 중복 컬럼 추가	
	•	업무프로세스상 JOIN이 필요한 경우가 많아 컬럼을 추가하는 것이 성능 측면에서 유리할 경우 고려한다.
	2. 파생 컬럼 추가
	•	프로세스 수행 시 부하가 염려되는 계산값을 미리 컬럼으로 추가하여 보관하는 방식으로 상품의 재고나 프로모션 적용 할인가 등이 이에 해당할 수 있다.
	3. 이력 테이블 컬럼 추가	
	•	대량의 이력 테이블을 조회할 때 속도가 느려질 것을 대비하여 조회 기준이 될 것으로 판단되는 컬럼을 미리 추가해 놓는 방식이다. 최신데이터 여부 등이 이에 해당할 수 있다.

모르는 단어 🫥
	◦	로우체이닝 : 한 로우의 데이터 크기가 블록의 데이터 저장 공간보다 클때 발생하는 현상.	(컬럼이 너무 많음)
	◦	파니셔닝 : 인스턴스 분할.
	◦	적시성 : 어떤 경제적 사건에 관한 정보가 너무 늦게 제공되어 의사결정에 영향을 미칠 수 있는 능력을 상실하기 전에 의사결정에 이용될 수 있도록 제공되어야 한다는 회계정보의 속성을 말한다.
	◦	빌링 : 유료 이용에 대한 대금 청구와 고객에 대한 관리 
	◦	튜플(tuple) :  셀 수 있는 수량의 순서 있는 열거이다.
	◦	카티시안 곱(Cartesian Product) : 발생가능한 모든 경우의 수의 행이 출력되는 것

	3.	관계 반정규화(중복관계 추가)
	•	업무 프로세스 상 JOIN이 필요한 경우가 많아 중복관계를 추가하는 것이 성능 측면에서 유리할 경우 고려한다.


03. 트랜잭션(Transaction)
	•	데이터를 조작하기 위한 하나의 논리적인 작업 단위이다. 
	•	쿠폰 나눠주는 이벤트 예시
	•	쪼갤 수 없는 업무 처리의 최소 단위 


04. NULL
	•	NULL이 포함된 사칙연산의 결과는 항상 NULL이다.
	•	데이터를 집계할 때 NULL은 집계 대상에서 제외된다.
	•	WHERE COL IS NOT NULL 조건은 COL이 NULL이 아닌 행만 출력하는 조건이다.
	•	IS NULL : 입력값을 확인하여 NULL이면 TRUE를 NULL이 아니면 FALSE를 리턴
	•	IS NOT NULL : IS NULL과는 반대로 입력값이 NULL이면 FALSE를 NULL이 아니면 TRUE를 리턴한다.



/////////////////////////////////////////////////////////////////////////////////////////////////////////



PART2 	SQL 기본 및 활용


CHAPTER 1 SQL 기본

01 관계형 데이터베이스 개요 
	1.	데이터베이스 
	2.	관계형 데이터 베이스
	RDB(Relational Database)
	RDBMS(Relational Database Management System) : RDB를 관리 감독하는 시스템
	Oracle, SQL Server(MSSQL), MySQL, MariaDB, PostgreSQL등이 속함.
	3.	TABLE
	•	세로 : 속성 : 컬럼(Column)
	•	가로 : 인스턴스 : 로우(low)
	4.	SQL(Structured Query Language)
	데이터베이스가 이해할 수 있는 언어

02 SELECT 문
	1.	SELECT
	•	SELECT문장의 실행 순서
	•	FROM - WHERE - GROUP BY - HAVING - SELECT - ORDER BY(FWGHSO)
	SELECT : 저장되어 있는 데이터를 조회
	*(asterisk) : 전체 컬럼 조회	
	WHERE : 테이블의 전체 ROW 조회
	Alias(별칭) 
	•	AS로 사용함
	•	테이블명이나 컬럼명에 붙일 수 있음
	•	이름 바꿀 수 있음(재명명한다는 뜻임.)

	2.	산술 연산자
	3.	합성 연산자 

03 함수

	1.	내장 함수(Built-in Function)
	•	단일행 함수(Single-Row Function)
	•	다중행 함수(Multi-Row Function)
	⁃	집계 함수(Aggregate Function)
	⁃	그룹 함수(Group Function)
	⁃	윈도우 함수(Window Function)
	2.	사용자 정의 함수(User Defined Function)
 

단일행 함수의 종류
	1.	문자 함수
	1.	CHR(ASCII 코드)
	•	ASCII 코드는 128개의 문자를  숫자로 표현할 수 있도록 정의해놓은 코드이다.
	2.	LOWER(문자열)
	•	문자열을 소문자로 변환해주는 함수이다.
	3.	UPPER(문자열)
	•	문자열을 대문자로 변환해주는 함수이다.
	4.	LTRIM(문자열 [,특정 문자])        *는 옵션
	•	왼쪽 공백 제거
	•	문자 지정 시 제거 가능
	5.	RTRIM(문자열 [,특정 문자])        *는 옵션
	•	오른쪽 공백 제거 
	•	문자 지정 시 제거 가능
	6.	TRIM(문자열 [,특정 문자])        *는 옵션
	•	왼쪽, 오른쪽 공백 제거
	•	문자 지정 시 제거 한 번 가능
	7.	SUBSTR(문자열, 시작점 [,길이]    *[]는 옵션
	•	문자열의 원하는 부분만 잘라서 반환해주는 함수
	•	길이 명시 안할 시 모든 문자열 반환
	8.	LENGTH(문자열)
	•	문자열의 길이를 반환해주는 함수이다.
	9.	REPLACE(문자열, 변경 전 문자열 [,변경 수 문자열])        *[]는 옵션
	•	문자열에서 변경 전 문자열을 찾아 변경 후 문자열로 바꿔주는 함수
	•	변경 후 문자열을 명시해주지 않으면 문자열에서 변경 전 문자열을 제거한다.
	10.	*concat(문자열1, 문자열2): 문자열1, 2 합친거.
	11.	*|| : 오라클에서는 문자열 합치는 걸로 씀, My sql에서는 OR으로 사용.

	2.	숫자 함수
	1.	ABS(수)
	•	수의 절대값을 반환해주는 함수이다.
	2.	SIGN(수)
	•	수의 부호를 반환해주는 함수
	•	양수면 1, 음수면 -1, 0이면 0반환
	3.	ROUND(수 [,자릿수])    *[]는 옵션
	•	수를 지정된 소수점 자릿수까지 반올림하여 반환해주는 함수이다.
	4.	TRUNC(수 [,자릿수]      *[]는 옵션
	•	수를 지정된 소수점 자릿수까지 버림하여 반환해주는 함수다.
	5.	CEIL(수)
	•	소수점 이하의 수를 올림한 정수를 반환해주는 함수다.
	6.	FLOOR(수)
	•	소수점 이하의 수를 버림한 정수를 반환해주는 함수이다.
	7.	MOD(수1, 수2)
	•	수1을 수2로 나눈 나머지를 반환해주는 함수이다.

	3.	날짜 함수
	1.	SYSDATE
	•	현재 연, 월, 일, 시, 분, 초를 반환해주는 함수다.
	2.	EXTRACT(특정 단위 FROM 날짜 데이터)
	•	날짜 데이터(YEAR,  MONTH, DAY, HOUR, MINUTE, SECOND)만을 출력해서 반환해주는 함수이다.
	3.	ADD_MONTHS(날짜 데이터, 특정 개월 수)
	•	날짜 데이터에서 특정 개월 수를 더한 날짜를 반환해주는 함수이다.

	4.	변환 함수
	1.	명시적 형변환과 암시적 형변환
	•	명시적 형변환 : 변환 함수를 사용하여 데이터 유형 변환을 명시적으로 나타냄
	•	암시적 형변환 : 데이터베이스가 내부적으로 알아서 데이터 유형을 변환함
	2.	명시적 형변환에 쓰이는 함수
	1.	TO_NUMBER(문자열)
	•	문자열을 숫자형으로 변환해주는 함수이다.
	2.	TO_CHAR(수 or 날짜 [, 포맷])     *[]는 옵션
	•	수나 날짜형의 데이터를 포맷 형식의 문자형으로 변환해주는 함수이다. 
	3.	TO_DATE(문자열, 포맷)
	•	포맷 형식의 문자형의 데이터를 날짜형으로 변환해주는 함수이다.

	5.	NULL 관련 함수
	1.	NVL(인수1, 인수2) = ISNULL(인수1, 인수2)
	•	인수1의 값이 NULL일 경우 인수2를 반환하고 NULL이 아닐 경우 인수 1을 반환해주는 함수이다.
	2.	NULLIF(인수1, 인수2)
	•	인수1과 인수2가 같으면 NULL을 반환하고 같지 않으면 인수1을 반환해주는 함수이다.
	3.	COALESCE(인수1, 인수2, 인수3 ...)
	•	NULL이 아닌 최초의 인수를 반환해주는 함수이다.

	6.	CASE
	•	함수보다 구문에 가까움


04 WHERE 절 
INSERT를 제외한 DML문을 수행할 때 원하는 데이터만 골라 수행할 수 있도록 해주는 구문이다.

	1.	비교 연산자
￼

	2.	부정 비교 연산자
￼

3.SQL 연산자
￼

	4.	부정 SQL 연산자 
￼

	5.	논리 연산자
￼

05 GROUP BY, HAVING 절 
	1.	GROUPBY
	•	데이터를 그룹별로 묶을 수 있도록 해주는 절
	•	똑같은 값을 묶어주기도 함.
	2.	집계함수
￼
	3.	HAVING
	•	GROUP BY 절을 사용할 때 WHERE 절처럼 사용하는 조건절이라고 생각하면된다.
	•	HAVING절은 Filter기 때문에 SELECT문 보다 선행처리된다.


06 ORDER BY 절 
	1.	ORDER BY
	•	SELECT 문에서 논리적으로 맨 마지막에 수행된다.
￼
￼


07 ORDER BY 절 
	1.	JOIN이란
	•	각기 다른 두 개의 집단이 합해질 때 주로 쓰인다.
	•	PK와 FK 값의 연관성에 의해 성립된다.
	2.	EQUL JOIN
	•	EQUL(=) 조건으로 JOIN하는 것
	3.	Non EQUL JOIN
	•	Equal(=) 조건이 아닌 다른 조건 (BETWEEN, >, >=, <, <=)으로 JOIN 하는 방식
	•	설계상의 이유로 수행이 불가능한 경우도 있다.
	4.	3개 이상 TABLE JOIN
	•	3개 이상의 테이블을 JOIN할 수 있음.
	5.	OUTER JOIN
	•	JOIN 조건에 만족하지 않는 행들도 출력되는 형태다.
	6.	DBMS 옵티마이저
	•	From 절에 나열된 테이블이 아무리 많아도 항상 2개의 테이블씩 짝을 지어 Join을 수행한다.
	•	ORACLE의 규칙기반 옵티마이저에서 가장 우선 순위가 높은 규칙은 Single row by rowid 엑세스 기법이다.
	•	비용기반 옵디마이저는 테이블, 인덱스, 컬럼 등 객체의 통계정보를 사용하여 실행계획을 수립하므로 통계정보가 변경되면 SQL의 실행계획이 달라질 수 있다.
	•	ORACLE의 실행계획에 나타나는 기본적인 Join 기법으로는 NL Join, Hash Join, Sort Merge Join 등이 있다.
	⁃	NL Join
	•	유니크 인덱스를 활용하여 수행시간이 적게 걸리는 소량 테이블을 온라인 조회하는 경우
	•	선택도가 낮은(결과 행의 수가 적은) 테이블이 선행 테이블로 선택되는 것이 일반적으로 유리하다.
	⁃	Hash Join
	•	
	⁃	Sort Merge Join



08 STANDARD JOIN 절 
	1.	INNER JOIN
	•	JOIN 조건에 충족하는 데이터만 출력되는 방식이다.
	2.	OUTER JOIN
	•	JOIN 조건에 충족하는 데이터가 아니어도 출력될 수 있는 방식이다.
	•	몇 가지 종류가 있다.
	1.	LEFT OUTER JOIN
	•	왼쪽에 표기된 테이블의 데이터는 무조건 출력되는 JOIN이다. 
	•	데이터가 없는 Row들은 오른쪽 테이블 컬럼의 값이 NULL로 출력된다.
	2.	RIGHT OUTER JOIN
	•	오른쪽에 표기된 테이블의 데이터는 무조건 출력되는 방식이다.
	•	데이터가 없는 Row들은 왼쪽 테이블 컬럼의 값이 NULL로 출력된다.
	3.	FULL OUTER JOIN
	•	왼쪽, 오른쪽 테이블의 데이터가 모두 출력되는 방식이다.
	3.	NATURAL JOIN
	•	A 테이블과 B 테이블에서 같은 이름을 가진 컬럼들이 모두 동일한 데이터를 가지고 있을 경우 JOIN이 되는 방식이다.
	4.	CROSS JOIN
	•	경우의 수
	•	일반 집합 연산자의 PRODUCT의 개념으로 테이블 간 JOIN 조건이 없는 경우 생길 수 있는 모든 데이터의 조합을 말한다.
		

	Nested Loop Join
	•	조인 칼럼에 적당한 인덱스가 있어서 자연조인(Natural join)이 효율적일 때 유용하다.
	•	Driving Table의 조인 데이터 양이 큰 영향을 주는 조인 방식이다.
	•	유니크 인덱스를 활용하여 수행시간이 적게 걸리는 소량 테이블을 온라인 조회하는 경우 유용하다.




CHAPTER 2 SQL 활용


01 서브쿼리(Subquery)
	•	하나의  쿼리 안에 존재하는 또 다른 쿼리이다. 
	•	메인쿼리, 서브쿼리가 있다.
￼

	1. 스칼라 서브쿼리(Scalar Subquery)
	•	주로 SELECT 절에 위치하지만 컬럼이 올 수 있는 대부분 위치에 사용할 수 있다.
	•	컬럼 대신 사용된다.
	•	반드시 하나의 값만을 반환해야 한다.
	2.	인라인 뷰(Inlince View)
	•	FROM 절 등 테이블명이 올 수 있는 위치에 사용 가능하다.
	3.	중첩 서브쿼리(Nested Subquery)
	1.	WHERE 절과 HAVING 절에 사용할 수 있다.
￼
	⁃	비연관 서브쿼리(Un-Correlated Subquery) : 서브쿼리 내에 메인 쿼리의 컬럼이 존재하지 않음
	⁃	연관 서브쿼리(Correlated Subquery) : 서브 뭐리 내에 메인 쿼리의 컬럼 존재
	2.	중첩 서브쿼리는 반환하는 데이터 형태에 따라 다음과 같이 나눌 수 있다.
￼
	⁃	단일 행 서브쿼리(Sigle Row Subquery) : 항상 1건 이하의 결과만 반환
	⁃	다중 행 서브쿼리(Multi Row Subquery) : 2건 이상의 행을 반환
	⁃	다중 컬럼 서브쿼리(Multi Column Subquery) : 


02 뷰(View)
	•	특정 SELECT 문에 이름을 붙여서 재사용이 가능하도록 저장해놓은 오브젝트이다.
	•	가상테이블이다.

특징
	1.	보안성 : 보안이 필요한 컬럼을 가진 테이블일 경우 해당 컬럼을 제외한 별도의 뷰를 생성하여 제공함으로써 보안을 유지할 수 있다.
	2.	독립성 : 테이블 스키마가 변경되었을 경우 어플리케이션은 변경하지 않고 관련 뷰만 수정한다.
	3.	편리성 : 복잡한 쿼리 구문을  뷰명으로 단축시킴으로써 가독성을 높이고 편리하게 사용할 수 있다.

03 집합 연산자 

UNION
	⁃	여러 개의 SQL문의 결과에 대한 합집합으로 결과에서 모든 중복된 행은 하나의 행으로 만든다.
UNIONALL
	⁃	여러 개의 SQL문의 결과에 대한 합집합으로 중복된 행도 그대로 결과로 표시된다.
	⁃	단순히 결과만 합쳐놓은 것이다.
	⁃	일반적으로 여러질의 결과가 상호 배타적인(Exclusive)일 때 많이 사용한다.
	⁃	개별 SQL문의 결과가 서로 중복되지 않는 경우, UNION과 결과가 동일하다.
INTERSECT(Intersection)
	⁃	여러 개의 SQL문의 결과에 대한 교집합이다.
	⁃	중복된 행은 하나의 행으로 만든다.
EXCEPT(DIFFERENCE, MINUS)
	⁃	앞의 SQL문의 결과에서 뒤의 SQL문의 결과에 대한 차집합이다.
	⁃	중복된 행은 하나의 행으로 만든다.
￼

04 그룹함수
￼
	1.	ROLLUP
￼
	2.	CUBE
￼
	3.	GROUPING SETS
￼
	4.	GROUPING
	•	ROLLUP, CUBE, GROUPING SETS 등과 함께 쓰이며 소계를 나타내는 Row를 구분할 수 있게 해준다. 

05 윈도우 함수
￼
	1.	순위 함수
￼
	1.	RANK
	•	순위를 매기면서 같은 순위가 존재하는 수만큼 다음 순위를 건너뛴다.
	2.	DENSE_RANK
	•	순위를 매기면서 같은 순위가 존재하더라도 다음 순위를 건너뛰지 않고 이어서 매긴다.
	3.	ROW_NUMBER
	•	순위를 매기면서 동일한 값이라도 각기 다른 순위를 부여한다.

	2.	집계 함수 
	1.	SUM
	•	데이터의 합계를 구하는 함수이다.
	2.	MAX
	•	데이터의 최댓값을 구하는 함수이다.
	3.	MIN
	•	데이터의 최솟값을 구하는 함수이다.
	4.	AVG
	•	데이터의 평균값을 구하는 함수이다.
	5.	COUNT
	•	데이터의 건수를 구하는 함수이다.

	3.	 행 순서 함수 
	1.	 FIRST_VALUE
	•	파티션 별 가장 선두에 위치한 데이터를 구하는 함수이다.
	•	SQL Server(MSSQL)에서는 지원하지 않는다.
	2.	LAST_VALUE
	•	파티션 별 가장 끝에 위치한 데이터를 구하는 함수이다.
	•	SQL Server(MSSQL)에서는 지원하지 않는다.
	3.	LAG
	•	파티션 별로 특정 수만큼 앞선 데이터를 구하는 함수이다. 
	•	SQL Server(MSSQL)에서는 지원하지 않는다.
	4.	LEAD
	•	파티션 별 특정 수만큼 뒤에 있는 데이터를 구하는 함수이다.
	•	SQL Server(MSSQL)에서는 지원하지 않는다.

	4.	비율 함수
	1.	RATIO_TO_REPORT
	•	파티션 별 합계에서 차지하는 비율을 구하는 함수이다.
	•	SQL Server(MSSQL)에서는 지원하지 않는다.
	2.	PERCENT_RANK
	•	해당 파티션의 맨 위 끝 행을 0, 맨 아래 끝 행을 1로 놓고 현재 행이 위치하는 백분위 순위 값을 구하는 함수이다.
	•	SQL Server(MSSQL)에서는 지원하지 않는다.
	3.	CUME_DIST
	•	해당 파티션에서의 누적 백분율을 구하는 함수이다.
	•	결과값은 0보다 크고 1보다 작거나 같은 값을 가진다.
	•	SQL Server(MSSQL)에서는 지원하지 않는다.
	4.	NTILE
	•	주어진 수만큼 행들을 n등분한 후 현재 행에 해당하는 등급을 구하는 함수이다.

06 Top-N 쿼리
	1.	ROWNUM
	•	슈도 컬럼(Pseudo Column)이다.
	•	실제로 존재하지 않는 가짜컬럼이다.
	2.	윈도우 함수의 순위 함수
	•	앞 절에 나왔던 윈도우 함수의 순위 함수를 이용하여 Top-N 쿼리를 작성할 수 있다.
	3.	Top
	•	TOP은 상위 N개의 데이터를 출력한다.
	4.	TOP WITH TIES 
	•	동일한 데이터가 있을 경우 함께 출력한다.
	•	ORDER BY절이 반드시 함께 와야 한다.

07 셀프 조인(Self Join)
	⁃	하나의 테이블에서 두 개의 칼럼이 연관 관계를 가지고 있는 경우에 사용한다.	

08 계층 쿼리
	1.	START WITH PARENT_CATEGORY IS NULL
	2.	CONNECT BY CATEGORY_NAME+PARENT_CATEGORY
	3.	CONNECT BY PRIOR CATEGORY_NAME+PARENT_CATEGORY


CHAPTER 3  관리 구문
01 DML
	•	데이터 조작어(Data Manipulation Language)
	•	DDL에서 정의한 대로 데이터를 입력하고, 입력된 데이터를 수정, 삭제, 조회하는 명령어이다.
	1.	INSERT
	•	테이블에 데이터를 입력하는 명령어이다.
	2.	UPDATE
	•	이미 저장된 데이터를 수정하고 싶을 때 사용하는 명령어이다.
	3.	DELETE
	•	이미 저장된 데이터를 삭제하고 싶을 때 사용하는 명령어이다.
	•	WHERE 절이 없으면 테이블의 모든 Row가 삭제되니 주의해야 한다.
	4.	MERGE
	•	테이블에 새로운 데이터를 입력하거나 이미 저장되어 있는 데이터에 대한 변경 작업을 한 번에 할 수 있도록 해주는 명령어이다.
	5.	SELECT
	•	데이터베이스에 들어 있는 데이터를 조회하거나 검색하기 위한 명령어
	•	RETRIEVE 이라고 불림 

02 TCL
	•	트랜잭션 제어어(Transaction Control Language)
	•	트랜잭션을 제어하는 명령어이다.
	1.	트랜잭션의 특징
￼
	2.	COMMIT
	•	INSERT, DELETE, UPDATE 후 변경된 내용을 확정, 반영하는 명령어이다. 
	•	COMMIT을 실행하지 않으면 메모리까지만 반영이 된다.
	•	UPDATE 한 뒤 오랜 시간 동안 COMMIT이나 ROLLBACK을 하지 않았을 경우 Lock에 걸려서 다른 사용자가 변경할 수 없는 상황이 발생할 수 있으니 주의해야 한다.
	3.	ROLLBACK
	•	INSERT, DELETE, UPDATE 후 변경된 내용을 취소하는 명령어이다.
	4.	SAVEPOINT
	•	ROLLBACK을 수행할 때 전체 작업을 되돌리지 않고 일부만 되돌릴 수 있게 하는 기능을 가진 명령어이다.
	•	ROLLBACK 뒤에 특정 SAVEPOINT를 지정해주면 그 지점까지만 데이터가 복구된다.
 03 DDL
￼
	•	데이터 정의어(Data Definition Language)
￼
	1.	CREATE
	•	테이블을 생성하기 위한 명령어이다. 

	2.	ALTER
	1.	ADD COLUMN
	•	새로운 컬럼을 추가할 때 쓰는 명령어이다.
	2.	DROP COLUMN
	•	기존에 있던 컬럼이 필요없어졌을 때 삭제하는 명령어이다.
	3.	MODIFY CORUMN
	•	기존에 있던 컬럼을 변경하고 싶을 때 쓰는 명령어이다. 
	4.	RENAME COLUMN
	•	기존에 있던 컬럼의 이름을 변경하고 싶을 때 쓰는 명령어이다.
	5.	ADD CONSTRAINT
	•	제약조건을 추가하고 싶을 때 쓰는 명령어이다.
	6.	DROP TABLE
	•	테이블을 삭제할 때 쓰는 명령어이다.
	7.	TRUNCATE TABLE
	•	테이블에 저장되어 있는 데이터를 모두 제거하는 명령어이다.

04 DCL
￼
	•	데이터 제어어
	•	DCL은 Data Control Language란 의미로 USER를 생성하고, USER에게 데이터를 컨트롤 할 수 있는 권한을 부여하거나 회수하는 명령어이다.
	1.	USER 관련 명령어
	1.	CREATE USER
	•	사용자를 생성하는 명령어이다.
	•	CREATE USER 권한이 있어야 수행 가능하다.
	2.	ALTER USER
	•	사용자를 변경하는 명령어이다.
	3.	DROP USER
	•	사용자를 삭제하는 명령어이다.
	2.	권한 관련 명령어
	1.	GRANT
	•	사용자에게 권한을 부여하는 명령어이다.
	2.	REVOKE
	•	사용자에게 권한을 회수하는 명령어이다.
	3.	ROLE 관련 명령어
	1.	ROLE을 이용한 권한 부여
	1.	ROLE을 생성한다.
	2.	ROLE에 권한을 부여한다.
	3.	ROLE을 사용자에게 부여한다.





￼
	- Delete(/Modify) Action 
	1.	Cascade : Master 삭제 시 Child 같이 삭제
	2.	Set Null : Master 삭제 시 Child 해당 필드 Null
	3.	Set Default : Master 삭제 시 Child 해당 필드 Default 값으로 설정
	4.	Restrict : Child 테이블에 PK 값이 없는 경우만 Master 삭제
	5.	No Action : 참조무결성을 위반하는 삭제/수정 액션을 취하지 않음

	- Insert Action 
	1.	Automatic : Master 테이블에 PK가 없는 경우 Master PK를 생성 후 Child 입력
	2.	Set Null : Master 테이블에 PK가 없는 경우 Child 외부키를 Null 값으로 처리
	3.	Set Default : Master 테이블에 PK가 없는 경우 Child 외부키를 지정된 기본값으로 입력
	4.	Dependent : Master 테이블에 PK가 존재할 때만 Child 입력 허용
	5.	No Action : 참조무결성을 위반하는 입력 액션을 취하지 않음


////////////////////////////////////////////////////////////////////////////////////////////////




데이터베이스 트랜잭션에 대한 격리성이 낮은 경우 발생할 수 있는 문제점.
	1.	Dirty Read : 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 데이터를 읽는 것을 말한다.
	2.	Non-Repeatable Read : 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제하는 바람에 두 쿼리 결과가 다르게 나타나는 현상을 말한다. 
	3.	Phantom Read : 한 트랜잭션 내에서 같은 쿼리를 두 번 수행했는데, 첫번째 쿼리에서 없던 유령 레코드가 두번째 쿼리에서 나타나는 현상을 말한다.



순수 관계 연산자 
	•	SELECT : WHERE 절로 구현
	•	PROJECT : SELECT 절로 구현
	•	JOIN : 다양한 JOIN 기능으로 구현
	•	DIVIDE	 : 현재 사용 안함.



관계형 데이터베이스의 인덱스(Index)
	•	기본 인덱스에 널 값(Null Value)들이 나타날 수 없다.
	•	테이블의 전체 데이터를 읽는 경우는 인덱스가 거의 불필요하다.
	•	B 트리는 관계형 데이터베이
	•	규칙기반 옵티마이저는 적절한 인텍스가 존재하면 항상 인덱스를 사용하려고 한다.
	•	인덱스 범위 스캔은 결과가 없으면 한 건도 반환하지 않을 수 있다.
	•	인덱스는 데이터 조회 목적에는 효과적이지만, INSERT, UPDATE, DELETE 작업에는 오히려 많은 부하를 줄 수도 있다.
	•	SQL Server의 클러스터형 인덱스는 ORACLE의 IOT와 매우 유사하다.
	•	인덱스는 INSERT와 DELETE 작업과는 다르게 UPDATE 작업에는 부하가 없을 수도 있다.





UNIQUE KEY(고유 키)
	- 값이 중복되지 않는다.
	- 값을 입력하지 않아도 된다. (NULL 허용)
	- 중복되면 안되는 데이터 (주민등록번호, 군번 등)


테이블의 제약조건(Constraint)
	- Check 제약조건(Constraint)은 데이터베이스에서 데이터의 무결성을 유지하기 위하여 테이블의 특정 컬럼(Column)에 설정하는 제약이다.
	- 기본키(Primary Key)는 반드시 테이블 당 하나의 제약만을 정의할 수 있다.
	- 고유키(Unique Key)로 지정된 모든 컬럼들은 Null 값을 가질 수 있다.
	- 외래키(Foreign Key)는 테이블간의 관계를 정의하기 위해 기본키(Primary Key)를 다른 테이블의 외래키가 참조하도록 생성한다.





*무결성 : 데이터의 정확성, 일관성을 나타내는 것
*무결성 제약조건 : 데이터베이스의 정확성, 일관성을 보장하기 위해 저장, 삭제, 수정 등을 제약하기 위한 조건 
*UNDO : 실행 취소 
*IN(list) : 리스트에 있는 값 중에서 어느 하나라도 일치하면 된다.
*START WITH절은 계층 구조 전개의 시작 위치를 지정하는 구문이다.
 즉, 루트 데이터를 지정한다.(액세스)
*ORDER SIBLINGS BY : 형제 노드(동일 LEVEL)사이에서 정렬을 수행한다.
*계층형 데이터 : 동일한 테이블에 계층적으로 상위와 하위 데이터가 포함되어진 데이터
*루트 노드 ( 루트 데이터 ) : 가장 최상위의 데이터
*리프노드 ( 리프 데이터 ) : 가장 최하위의 데이터
*순방향전개 : 부모 노드로부터 자식 노드 방향으로 전개하는 것을 말한다.


DISTINCT : 중복된 데이터가 있는 경우 1건으로 처리해서 출력한다.
















		








